"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = waitForDisplayed;

require("source-map-support/register");

/**
 *
 * Wait for an element for the provided amount of
 * milliseconds to be displayed or not displayed.
 *
 * <example>
    :index.html
    <div id="elem" style="visibility: hidden;">Hello World!</div>
    <script type="text/javascript">
        setTimeout(() => {
            document.getElementById('elem').style.visibility = 'visible';
        }, 2000);
    </script>
    :waitForVisibleExample.js
    it('should detect when element is visible', () => {
        const elem = $('#elem')
        elem.waitForDisplayed(3000);
    });
 * </example>
 *
 * @alias element.waitForDisplayed
 * @param {Number=}  ms       time in ms (default: 500)
 * @param {Boolean=} reverse  if true it waits for the opposite (default: false)
 * @param {String=}  error    if exists it overrides the default error message
 * @uses utility/waitUntil, state/isDisplayed
 * @type utility
 *
 */
async function waitForDisplayed(ms, reverse = false, error) {
  /**
   * if element wasn't found in the first place wait for its existance first
   */
  if (!this.elementId && !reverse) {
    await this.waitForExist(ms);
  }
  /*
   * ensure that ms is set properly
   */


  if (typeof ms !== 'number') {
    ms = this.options.waitforTimeout;
  }

  const isReversed = reverse ? '' : 'not ';
  const errorMsg = typeof error === 'string' ? error : `element ("${this.selector}") still ${isReversed}displayed after ${ms}ms`;
  return this.waitUntil(async () => {
    const isVisible = await this.isElementDisplayed(this.elementId);
    return isVisible !== reverse;
  }, ms, errorMsg);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21tYW5kcy9lbGVtZW50L3dhaXRGb3JEaXNwbGF5ZWQuanMiXSwibmFtZXMiOlsid2FpdEZvckRpc3BsYXllZCIsIm1zIiwicmV2ZXJzZSIsImVycm9yIiwiZWxlbWVudElkIiwid2FpdEZvckV4aXN0Iiwib3B0aW9ucyIsIndhaXRmb3JUaW1lb3V0IiwiaXNSZXZlcnNlZCIsImVycm9yTXNnIiwic2VsZWN0b3IiLCJ3YWl0VW50aWwiLCJpc1Zpc2libGUiLCJpc0VsZW1lbnREaXNwbGF5ZWQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkJlLGVBQWVBLGdCQUFmLENBQWlDQyxFQUFqQyxFQUFxQ0MsT0FBTyxHQUFHLEtBQS9DLEVBQXNEQyxLQUF0RCxFQUE2RDtBQUN4RTs7O0FBR0EsTUFBSSxDQUFDLEtBQUtDLFNBQU4sSUFBbUIsQ0FBQ0YsT0FBeEIsRUFBaUM7QUFDN0IsVUFBTSxLQUFLRyxZQUFMLENBQWtCSixFQUFsQixDQUFOO0FBQ0g7QUFFRDs7Ozs7QUFHQSxNQUFJLE9BQU9BLEVBQVAsS0FBYyxRQUFsQixFQUE0QjtBQUN4QkEsSUFBQUEsRUFBRSxHQUFHLEtBQUtLLE9BQUwsQ0FBYUMsY0FBbEI7QUFDSDs7QUFFRCxRQUFNQyxVQUFVLEdBQUdOLE9BQU8sR0FBRyxFQUFILEdBQVEsTUFBbEM7QUFDQSxRQUFNTyxRQUFRLEdBQUcsT0FBT04sS0FBUCxLQUFpQixRQUFqQixHQUE0QkEsS0FBNUIsR0FBcUMsYUFBWSxLQUFLTyxRQUFTLFlBQVdGLFVBQVcsbUJBQWtCUCxFQUFHLElBQTNIO0FBRUEsU0FBTyxLQUFLVSxTQUFMLENBQWUsWUFBWTtBQUM5QixVQUFNQyxTQUFTLEdBQUcsTUFBTSxLQUFLQyxrQkFBTCxDQUF3QixLQUFLVCxTQUE3QixDQUF4QjtBQUVBLFdBQU9RLFNBQVMsS0FBS1YsT0FBckI7QUFDSCxHQUpNLEVBSUpELEVBSkksRUFJQVEsUUFKQSxDQUFQO0FBS0giLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICpcbiAqIFdhaXQgZm9yIGFuIGVsZW1lbnQgZm9yIHRoZSBwcm92aWRlZCBhbW91bnQgb2ZcbiAqIG1pbGxpc2Vjb25kcyB0byBiZSBkaXNwbGF5ZWQgb3Igbm90IGRpc3BsYXllZC5cbiAqXG4gKiA8ZXhhbXBsZT5cbiAgICA6aW5kZXguaHRtbFxuICAgIDxkaXYgaWQ9XCJlbGVtXCIgc3R5bGU9XCJ2aXNpYmlsaXR5OiBoaWRkZW47XCI+SGVsbG8gV29ybGQhPC9kaXY+XG4gICAgPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCI+XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2VsZW0nKS5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICB9LCAyMDAwKTtcbiAgICA8L3NjcmlwdD5cbiAgICA6d2FpdEZvclZpc2libGVFeGFtcGxlLmpzXG4gICAgaXQoJ3Nob3VsZCBkZXRlY3Qgd2hlbiBlbGVtZW50IGlzIHZpc2libGUnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW0gPSAkKCcjZWxlbScpXG4gICAgICAgIGVsZW0ud2FpdEZvckRpc3BsYXllZCgzMDAwKTtcbiAgICB9KTtcbiAqIDwvZXhhbXBsZT5cbiAqXG4gKiBAYWxpYXMgZWxlbWVudC53YWl0Rm9yRGlzcGxheWVkXG4gKiBAcGFyYW0ge051bWJlcj19ICBtcyAgICAgICB0aW1lIGluIG1zIChkZWZhdWx0OiA1MDApXG4gKiBAcGFyYW0ge0Jvb2xlYW49fSByZXZlcnNlICBpZiB0cnVlIGl0IHdhaXRzIGZvciB0aGUgb3Bwb3NpdGUgKGRlZmF1bHQ6IGZhbHNlKVxuICogQHBhcmFtIHtTdHJpbmc9fSAgZXJyb3IgICAgaWYgZXhpc3RzIGl0IG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBlcnJvciBtZXNzYWdlXG4gKiBAdXNlcyB1dGlsaXR5L3dhaXRVbnRpbCwgc3RhdGUvaXNEaXNwbGF5ZWRcbiAqIEB0eXBlIHV0aWxpdHlcbiAqXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gd2FpdEZvckRpc3BsYXllZCAobXMsIHJldmVyc2UgPSBmYWxzZSwgZXJyb3IpIHtcbiAgICAvKipcbiAgICAgKiBpZiBlbGVtZW50IHdhc24ndCBmb3VuZCBpbiB0aGUgZmlyc3QgcGxhY2Ugd2FpdCBmb3IgaXRzIGV4aXN0YW5jZSBmaXJzdFxuICAgICAqL1xuICAgIGlmICghdGhpcy5lbGVtZW50SWQgJiYgIXJldmVyc2UpIHtcbiAgICAgICAgYXdhaXQgdGhpcy53YWl0Rm9yRXhpc3QobXMpXG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBlbnN1cmUgdGhhdCBtcyBpcyBzZXQgcHJvcGVybHlcbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIG1zICE9PSAnbnVtYmVyJykge1xuICAgICAgICBtcyA9IHRoaXMub3B0aW9ucy53YWl0Zm9yVGltZW91dFxuICAgIH1cblxuICAgIGNvbnN0IGlzUmV2ZXJzZWQgPSByZXZlcnNlID8gJycgOiAnbm90ICdcbiAgICBjb25zdCBlcnJvck1zZyA9IHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycgPyBlcnJvciA6IGBlbGVtZW50IChcIiR7dGhpcy5zZWxlY3Rvcn1cIikgc3RpbGwgJHtpc1JldmVyc2VkfWRpc3BsYXllZCBhZnRlciAke21zfW1zYFxuXG4gICAgcmV0dXJuIHRoaXMud2FpdFVudGlsKGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gYXdhaXQgdGhpcy5pc0VsZW1lbnREaXNwbGF5ZWQodGhpcy5lbGVtZW50SWQpXG5cbiAgICAgICAgcmV0dXJuIGlzVmlzaWJsZSAhPT0gcmV2ZXJzZVxuICAgIH0sIG1zLCBlcnJvck1zZylcbn1cbiJdfQ==