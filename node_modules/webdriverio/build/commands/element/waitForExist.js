"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = waitForExist;

require("source-map-support/register");

/**
 *
 * Wait for an element for the provided amount of
 * milliseconds to be present within the DOM. Returns true if the selector
 * matches at least one element that exists in the DOM, otherwise throws an
 * error. If the reverse flag is true, the command will instead return true
 * if the selector does not match any elements.
 *
 * <example>
    :waitForExistSyncExample.js
    it('should display a notification message after successful form submit', function () {
        const form = $('form');
        const notification = $('.notification');
        form.submit();
        notification.waitForExist(5000); // same as `browser.waitForExist('.notification', 5000)`
        expect(notification.getText()).to.be.equal('Data transmitted successfully!')
    });
 * </example>
 *
 * @alias element.waitForExist
 * @param {Number=}  ms       time in ms (default: 500)
 * @param {Boolean=} reverse  if true it instead waits for the selector to not match any elements (default: false)
 * @param {String=}  error    if exists it overrides the default error message
 * @uses utility/waitUntil, state/isExisting
 * @type utility
 *
 */
function waitForExist(ms, reverse = false, error) {
  /*!
   * ensure that ms is set properly
   */
  if (typeof ms !== 'number') {
    ms = this.options.waitforTimeout;
  }

  const isReversed = reverse ? '' : 'not ';
  const errorMsg = typeof error === 'string' ? error : `element ("${this.selector}") still ${isReversed}existing after ${ms}ms`;
  return this.waitUntil(function async() {
    return this.isExisting().then(isExisting => isExisting !== reverse);
  }, ms, errorMsg);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21tYW5kcy9lbGVtZW50L3dhaXRGb3JFeGlzdC5qcyJdLCJuYW1lcyI6WyJ3YWl0Rm9yRXhpc3QiLCJtcyIsInJldmVyc2UiLCJlcnJvciIsIm9wdGlvbnMiLCJ3YWl0Zm9yVGltZW91dCIsImlzUmV2ZXJzZWQiLCJlcnJvck1zZyIsInNlbGVjdG9yIiwid2FpdFVudGlsIiwiYXN5bmMiLCJpc0V4aXN0aW5nIiwidGhlbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRCZSxTQUFTQSxZQUFULENBQXVCQyxFQUF2QixFQUEyQkMsT0FBTyxHQUFHLEtBQXJDLEVBQTRDQyxLQUE1QyxFQUFtRDtBQUM5RDs7O0FBR0EsTUFBSSxPQUFPRixFQUFQLEtBQWMsUUFBbEIsRUFBNEI7QUFDeEJBLElBQUFBLEVBQUUsR0FBRyxLQUFLRyxPQUFMLENBQWFDLGNBQWxCO0FBQ0g7O0FBRUQsUUFBTUMsVUFBVSxHQUFHSixPQUFPLEdBQUcsRUFBSCxHQUFRLE1BQWxDO0FBQ0EsUUFBTUssUUFBUSxHQUFHLE9BQU9KLEtBQVAsS0FBaUIsUUFBakIsR0FBNEJBLEtBQTVCLEdBQXFDLGFBQVksS0FBS0ssUUFBUyxZQUFXRixVQUFXLGtCQUFpQkwsRUFBRyxJQUExSDtBQUVBLFNBQU8sS0FBS1EsU0FBTCxDQUFlLFNBQVNDLEtBQVQsR0FBa0I7QUFDcEMsV0FBTyxLQUFLQyxVQUFMLEdBQWtCQyxJQUFsQixDQUF3QkQsVUFBRCxJQUFnQkEsVUFBVSxLQUFLVCxPQUF0RCxDQUFQO0FBQ0gsR0FGTSxFQUVKRCxFQUZJLEVBRUFNLFFBRkEsQ0FBUDtBQUdIIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqXG4gKiBXYWl0IGZvciBhbiBlbGVtZW50IGZvciB0aGUgcHJvdmlkZWQgYW1vdW50IG9mXG4gKiBtaWxsaXNlY29uZHMgdG8gYmUgcHJlc2VudCB3aXRoaW4gdGhlIERPTS4gUmV0dXJucyB0cnVlIGlmIHRoZSBzZWxlY3RvclxuICogbWF0Y2hlcyBhdCBsZWFzdCBvbmUgZWxlbWVudCB0aGF0IGV4aXN0cyBpbiB0aGUgRE9NLCBvdGhlcndpc2UgdGhyb3dzIGFuXG4gKiBlcnJvci4gSWYgdGhlIHJldmVyc2UgZmxhZyBpcyB0cnVlLCB0aGUgY29tbWFuZCB3aWxsIGluc3RlYWQgcmV0dXJuIHRydWVcbiAqIGlmIHRoZSBzZWxlY3RvciBkb2VzIG5vdCBtYXRjaCBhbnkgZWxlbWVudHMuXG4gKlxuICogPGV4YW1wbGU+XG4gICAgOndhaXRGb3JFeGlzdFN5bmNFeGFtcGxlLmpzXG4gICAgaXQoJ3Nob3VsZCBkaXNwbGF5IGEgbm90aWZpY2F0aW9uIG1lc3NhZ2UgYWZ0ZXIgc3VjY2Vzc2Z1bCBmb3JtIHN1Ym1pdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZm9ybSA9ICQoJ2Zvcm0nKTtcbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uID0gJCgnLm5vdGlmaWNhdGlvbicpO1xuICAgICAgICBmb3JtLnN1Ym1pdCgpO1xuICAgICAgICBub3RpZmljYXRpb24ud2FpdEZvckV4aXN0KDUwMDApOyAvLyBzYW1lIGFzIGBicm93c2VyLndhaXRGb3JFeGlzdCgnLm5vdGlmaWNhdGlvbicsIDUwMDApYFxuICAgICAgICBleHBlY3Qobm90aWZpY2F0aW9uLmdldFRleHQoKSkudG8uYmUuZXF1YWwoJ0RhdGEgdHJhbnNtaXR0ZWQgc3VjY2Vzc2Z1bGx5IScpXG4gICAgfSk7XG4gKiA8L2V4YW1wbGU+XG4gKlxuICogQGFsaWFzIGVsZW1lbnQud2FpdEZvckV4aXN0XG4gKiBAcGFyYW0ge051bWJlcj19ICBtcyAgICAgICB0aW1lIGluIG1zIChkZWZhdWx0OiA1MDApXG4gKiBAcGFyYW0ge0Jvb2xlYW49fSByZXZlcnNlICBpZiB0cnVlIGl0IGluc3RlYWQgd2FpdHMgZm9yIHRoZSBzZWxlY3RvciB0byBub3QgbWF0Y2ggYW55IGVsZW1lbnRzIChkZWZhdWx0OiBmYWxzZSlcbiAqIEBwYXJhbSB7U3RyaW5nPX0gIGVycm9yICAgIGlmIGV4aXN0cyBpdCBvdmVycmlkZXMgdGhlIGRlZmF1bHQgZXJyb3IgbWVzc2FnZVxuICogQHVzZXMgdXRpbGl0eS93YWl0VW50aWwsIHN0YXRlL2lzRXhpc3RpbmdcbiAqIEB0eXBlIHV0aWxpdHlcbiAqXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2FpdEZvckV4aXN0IChtcywgcmV2ZXJzZSA9IGZhbHNlLCBlcnJvcikge1xuICAgIC8qIVxuICAgICAqIGVuc3VyZSB0aGF0IG1zIGlzIHNldCBwcm9wZXJseVxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgbXMgIT09ICdudW1iZXInKSB7XG4gICAgICAgIG1zID0gdGhpcy5vcHRpb25zLndhaXRmb3JUaW1lb3V0XG4gICAgfVxuXG4gICAgY29uc3QgaXNSZXZlcnNlZCA9IHJldmVyc2UgPyAnJyA6ICdub3QgJ1xuICAgIGNvbnN0IGVycm9yTXNnID0gdHlwZW9mIGVycm9yID09PSAnc3RyaW5nJyA/IGVycm9yIDogYGVsZW1lbnQgKFwiJHt0aGlzLnNlbGVjdG9yfVwiKSBzdGlsbCAke2lzUmV2ZXJzZWR9ZXhpc3RpbmcgYWZ0ZXIgJHttc31tc2BcblxuICAgIHJldHVybiB0aGlzLndhaXRVbnRpbChmdW5jdGlvbiBhc3luYyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRXhpc3RpbmcoKS50aGVuKChpc0V4aXN0aW5nKSA9PiBpc0V4aXN0aW5nICE9PSByZXZlcnNlKVxuICAgIH0sIG1zLCBlcnJvck1zZylcbn1cbiJdfQ==