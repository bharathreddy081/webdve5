"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = waitForEnabled;

require("source-map-support/register");

/**
 *
 * Wait for an element (selected by css selector) for the provided amount of
 * milliseconds to be (dis/en)abled. If multiple elements get queried by given
 * selector, it returns true (or false if reverse flag is set) if at least one
 * element is (dis/en)abled.
 *
 * <example>
    :index.html
    <input type="text" id="username" value="foobar" disabled="disabled"></input>
    <script type="text/javascript">
        setTimeout(() => {
            document.getElementById('username').disabled = false
        }, 2000);
    </script>
    :waitForEnabledExample.js
    it('should detect when element is enabled', () => {
        $('#username').waitForEnabled(3000);
    });

    it('should detect when element is disabled', () => {
        elem = $('#username');
        elem.waitForEnabled(3000, true)
    });
 * </example>
 *
 * @alias element.waitForEnabled
 * @param {Number=}  ms       time in ms (default: 500)
 * @param {Boolean=} reverse  if true it waits for the opposite (default: false)
 * @param {String=}  error    if exists it overrides the default error message
 * @uses utility/waitUntil, state/isEnabled
 * @type utility
 *
 */
async function waitForEnabled(ms, reverse = false, error) {
  // If the element doesn't already exist, wait for it to exist
  if (!this.elementId && !reverse) {
    await this.waitForExist(ms);
  }

  if (typeof ms !== 'number') {
    ms = this.options.waitforTimeout;
  }

  const isReversed = reverse ? '' : 'not ';
  const errorMessage = typeof error === 'string' ? error : `element ("${this.selector}") still ${isReversed}enabled after ${ms}ms`;
  return this.waitUntil(async () => {
    const isEnabled = await this.isEnabled();
    return isEnabled !== reverse;
  }, ms, errorMessage);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21tYW5kcy9lbGVtZW50L3dhaXRGb3JFbmFibGVkLmpzIl0sIm5hbWVzIjpbIndhaXRGb3JFbmFibGVkIiwibXMiLCJyZXZlcnNlIiwiZXJyb3IiLCJlbGVtZW50SWQiLCJ3YWl0Rm9yRXhpc3QiLCJvcHRpb25zIiwid2FpdGZvclRpbWVvdXQiLCJpc1JldmVyc2VkIiwiZXJyb3JNZXNzYWdlIiwic2VsZWN0b3IiLCJ3YWl0VW50aWwiLCJpc0VuYWJsZWQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUNlLGVBQWVBLGNBQWYsQ0FBOEJDLEVBQTlCLEVBQWtDQyxPQUFPLEdBQUcsS0FBNUMsRUFBbURDLEtBQW5ELEVBQTBEO0FBQ3JFO0FBQ0EsTUFBSSxDQUFDLEtBQUtDLFNBQU4sSUFBbUIsQ0FBQ0YsT0FBeEIsRUFBaUM7QUFDN0IsVUFBTSxLQUFLRyxZQUFMLENBQWtCSixFQUFsQixDQUFOO0FBQ0g7O0FBRUQsTUFBSSxPQUFPQSxFQUFQLEtBQWMsUUFBbEIsRUFBNEI7QUFDeEJBLElBQUFBLEVBQUUsR0FBRyxLQUFLSyxPQUFMLENBQWFDLGNBQWxCO0FBQ0g7O0FBRUQsUUFBTUMsVUFBVSxHQUFHTixPQUFPLEdBQUcsRUFBSCxHQUFRLE1BQWxDO0FBQ0EsUUFBTU8sWUFBWSxHQUFHLE9BQU9OLEtBQVAsS0FBaUIsUUFBakIsR0FBNEJBLEtBQTVCLEdBQXFDLGFBQVksS0FBS08sUUFBUyxZQUFXRixVQUFXLGlCQUFnQlAsRUFBRyxJQUE3SDtBQUVBLFNBQU8sS0FBS1UsU0FBTCxDQUFlLFlBQVk7QUFDOUIsVUFBTUMsU0FBUyxHQUFHLE1BQU0sS0FBS0EsU0FBTCxFQUF4QjtBQUVBLFdBQU9BLFNBQVMsS0FBS1YsT0FBckI7QUFDSCxHQUpNLEVBSUpELEVBSkksRUFJQVEsWUFKQSxDQUFQO0FBS0giLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqXG4gKiBXYWl0IGZvciBhbiBlbGVtZW50IChzZWxlY3RlZCBieSBjc3Mgc2VsZWN0b3IpIGZvciB0aGUgcHJvdmlkZWQgYW1vdW50IG9mXG4gKiBtaWxsaXNlY29uZHMgdG8gYmUgKGRpcy9lbilhYmxlZC4gSWYgbXVsdGlwbGUgZWxlbWVudHMgZ2V0IHF1ZXJpZWQgYnkgZ2l2ZW5cbiAqIHNlbGVjdG9yLCBpdCByZXR1cm5zIHRydWUgKG9yIGZhbHNlIGlmIHJldmVyc2UgZmxhZyBpcyBzZXQpIGlmIGF0IGxlYXN0IG9uZVxuICogZWxlbWVudCBpcyAoZGlzL2VuKWFibGVkLlxuICpcbiAqIDxleGFtcGxlPlxuICAgIDppbmRleC5odG1sXG4gICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9XCJ1c2VybmFtZVwiIHZhbHVlPVwiZm9vYmFyXCIgZGlzYWJsZWQ9XCJkaXNhYmxlZFwiPjwvaW5wdXQ+XG4gICAgPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCI+XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3VzZXJuYW1lJykuZGlzYWJsZWQgPSBmYWxzZVxuICAgICAgICB9LCAyMDAwKTtcbiAgICA8L3NjcmlwdD5cbiAgICA6d2FpdEZvckVuYWJsZWRFeGFtcGxlLmpzXG4gICAgaXQoJ3Nob3VsZCBkZXRlY3Qgd2hlbiBlbGVtZW50IGlzIGVuYWJsZWQnLCAoKSA9PiB7XG4gICAgICAgICQoJyN1c2VybmFtZScpLndhaXRGb3JFbmFibGVkKDMwMDApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBkZXRlY3Qgd2hlbiBlbGVtZW50IGlzIGRpc2FibGVkJywgKCkgPT4ge1xuICAgICAgICBlbGVtID0gJCgnI3VzZXJuYW1lJyk7XG4gICAgICAgIGVsZW0ud2FpdEZvckVuYWJsZWQoMzAwMCwgdHJ1ZSlcbiAgICB9KTtcbiAqIDwvZXhhbXBsZT5cbiAqXG4gKiBAYWxpYXMgZWxlbWVudC53YWl0Rm9yRW5hYmxlZFxuICogQHBhcmFtIHtOdW1iZXI9fSAgbXMgICAgICAgdGltZSBpbiBtcyAoZGVmYXVsdDogNTAwKVxuICogQHBhcmFtIHtCb29sZWFuPX0gcmV2ZXJzZSAgaWYgdHJ1ZSBpdCB3YWl0cyBmb3IgdGhlIG9wcG9zaXRlIChkZWZhdWx0OiBmYWxzZSlcbiAqIEBwYXJhbSB7U3RyaW5nPX0gIGVycm9yICAgIGlmIGV4aXN0cyBpdCBvdmVycmlkZXMgdGhlIGRlZmF1bHQgZXJyb3IgbWVzc2FnZVxuICogQHVzZXMgdXRpbGl0eS93YWl0VW50aWwsIHN0YXRlL2lzRW5hYmxlZFxuICogQHR5cGUgdXRpbGl0eVxuICpcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiB3YWl0Rm9yRW5hYmxlZChtcywgcmV2ZXJzZSA9IGZhbHNlLCBlcnJvcikge1xuICAgIC8vIElmIHRoZSBlbGVtZW50IGRvZXNuJ3QgYWxyZWFkeSBleGlzdCwgd2FpdCBmb3IgaXQgdG8gZXhpc3RcbiAgICBpZiAoIXRoaXMuZWxlbWVudElkICYmICFyZXZlcnNlKSB7XG4gICAgICAgIGF3YWl0IHRoaXMud2FpdEZvckV4aXN0KG1zKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbXMgIT09ICdudW1iZXInKSB7XG4gICAgICAgIG1zID0gdGhpcy5vcHRpb25zLndhaXRmb3JUaW1lb3V0XG4gICAgfVxuXG4gICAgY29uc3QgaXNSZXZlcnNlZCA9IHJldmVyc2UgPyAnJyA6ICdub3QgJ1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycgPyBlcnJvciA6IGBlbGVtZW50IChcIiR7dGhpcy5zZWxlY3Rvcn1cIikgc3RpbGwgJHtpc1JldmVyc2VkfWVuYWJsZWQgYWZ0ZXIgJHttc31tc2BcblxuICAgIHJldHVybiB0aGlzLndhaXRVbnRpbChhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzRW5hYmxlZCA9IGF3YWl0IHRoaXMuaXNFbmFibGVkKClcblxuICAgICAgICByZXR1cm4gaXNFbmFibGVkICE9PSByZXZlcnNlXG4gICAgfSwgbXMsIGVycm9yTWVzc2FnZSlcbn1cbiJdfQ==