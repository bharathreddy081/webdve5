"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "executeHooksWithArgs", {
  enumerable: true,
  get: function () {
    return _executeHooksWithArgs.default;
  }
});
Object.defineProperty(exports, "runFnInFiberContext", {
  enumerable: true,
  get: function () {
    return _runFnInFiberContext.default;
  }
});
Object.defineProperty(exports, "wrapCommand", {
  enumerable: true,
  get: function () {
    return _wrapCommand.default;
  }
});
exports.executeAsync = exports.executeSync = exports.runTestInFiberContext = void 0;

require("source-map-support/register");

var _fibers = _interopRequireDefault(require("fibers"));

var _logger = _interopRequireDefault(require("@wdio/logger"));

var _executeHooksWithArgs = _interopRequireDefault(require("./executeHooksWithArgs"));

var _runFnInFiberContext = _interopRequireDefault(require("./runFnInFiberContext"));

var _wrapCommand = _interopRequireDefault(require("./wrapCommand"));

var _constants = require("./constants");

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = (0, _logger.default)('wdio-sync');
/**
 * execute test or hook synchronously
 * @param  {Function} fn         spec or hook method
 * @param  {Number}   repeatTest number of retries
 * @return {Promise}             that gets resolved once test/hook is done or was retried enough
 */

const executeSync = function (fn, repeatTest = 0, args = []) {
  /**
   * if a new hook gets executed we can assume that all commands should have finised
   * with exception of timeouts where `commandIsRunning` will never be reset but here
   */
  // commandIsRunning = false
  return new Promise((resolve, reject) => {
    try {
      const res = fn.apply(this, args);
      resolve(res);
    } catch (e) {
      if (repeatTest) {
        return resolve(executeSync(fn, --repeatTest, args));
      }
      /**
       * no need to modify stack if no stack available
       */


      if (!e.stack) {
        return reject(e);
      }

      e.stack = e.stack.split('\n').filter(_constants.STACKTRACE_FILTER_FN).join('\n');
      reject(e);
    }
  });
};
/**
 * execute test or hook asynchronously
 * @param  {Function} fn         spec or hook method
 * @param  {Number}   repeatTest number of retries
 * @return {Promise}             that gets resolved once test/hook is done or was retried enough
 */


exports.executeSync = executeSync;

const executeAsync = function (fn, repeatTest = 0, args = []) {
  let result, error;
  /**
   * if a new hook gets executed we can assume that all commands should have finised
   * with exception of timeouts where `commandIsRunning` will never be reset but here
   */
  // commandIsRunning = false

  try {
    result = fn.apply(this, args);
  } catch (e) {
    error = e;
  }
  /**
   * handle errors that get thrown directly and are not cause by
   * rejected promises
   */


  if (error) {
    if (repeatTest) {
      return executeAsync(fn, --repeatTest, args);
    }

    return new Promise((resolve, reject) => reject(error));
  }
  /**
   * if we don't retry just return result
   */


  if (repeatTest === 0 || !result || typeof result.catch !== 'function') {
    return new Promise(resolve => resolve(result));
  }
  /**
   * handle promise response
   */


  return result.catch(e => {
    if (repeatTest) {
      return executeAsync(fn, --repeatTest, args);
    }

    e.stack = e.stack.split('\n').filter(_constants.STACKTRACE_FILTER_FN).join('\n');
    return Promise.reject(e);
  });
};
/**
 * runs a hook within fibers context (if function name is not async)
 * it also executes before/after hook hook
 *
 * @param  {Function} hookFn      function that was passed to the framework hook
 * @param  {Function} origFn      original framework hook function
 * @param  {Function} before      before hook hook
 * @param  {Function} after       after hook hook
 * @param  {Number}   repeatTest  number of retries if hook fails
 * @return {Function}             wrapped framework hook function
 */


exports.executeAsync = executeAsync;

const runHook = function (hookFn, origFn, before, after, repeatTest = 0) {
  const hookError = hookName => e => log.error(`Error in ${hookName}: ${e.stack}`);

  return origFn(function (...hookArgs) {
    // Print errors encountered in beforeHook and afterHook to console, but
    // don't propagate them to avoid failing the test. However, errors in
    // framework hook functions should fail the test, so propagate those.
    return (0, _executeHooksWithArgs.default)(before).catch(hookError('beforeHook')).then(() => {
      /**
       * user wants handle async command using promises, no need to wrap in fiber context
       */
      if (hookFn.name === 'async') {
        return executeAsync.call(this, hookFn, repeatTest, (0, _utils.filterSpecArgs)(hookArgs));
      }

      return new Promise(runSync.call(this, hookFn, repeatTest, (0, _utils.filterSpecArgs)(hookArgs)));
    }).then(() => {
      return (0, _executeHooksWithArgs.default)(after).catch(hookError('afterHook'));
    });
  });
};
/**
 * runs a spec function (test function) within the fibers context
 * @param  {string}   specTitle   test description
 * @param  {Function} specFn      test function that got passed in from the user
 * @param  {Function} origFn      original framework test function
 * @param  {Number}   repeatTest  number of retries if test fails
 * @return {Function}             wrapped test function
 */


const runSpec = function (specTitle, specFn, origFn, repeatTest = 0) {
  /**
   * user wants handle async command using promises, no need to wrap in fiber context
   */
  if (specFn.name === 'async') {
    return origFn(specTitle, function async(...specArgs) {
      return executeAsync.call(this, specFn, repeatTest, (0, _utils.filterSpecArgs)(specArgs));
    });
  }

  return origFn(specTitle, function (...specArgs) {
    return new Promise(runSync.call(this, specFn, repeatTest, (0, _utils.filterSpecArgs)(specArgs)));
  });
};
/**
 * run hook or spec via executeSync
 */


function runSync(fn, repeatTest = 0, args = []) {
  return (resolve, reject) => (0, _fibers.default)(() => executeSync.call(this, fn, repeatTest, args).then(() => resolve(), reject)).run();
}
/**
 * wraps hooks and test function of a framework within a fiber context
 * @param  {String}   fnName               spec function that is being overwritten
 * @param  {Function} origFn               original framework function
 * @param  {String[]} testInterfaceFnNames command that runs specs, e.g. `it`, `it.only` or `fit`
 * @param  {Function} before               before hook hook
 * @param  {Function} after                after hook hook
 * @return {Function}                      wrapped test/hook function
 */


const wrapTestFunction = function (fnName, origFn, testInterfaceFnNames, before, after) {
  return function (...specArguments) {
    /**
     * Variadic arguments:
     * [title, fn], [title], [fn]
     * [title, fn, retryCnt], [title, retryCnt], [fn, retryCnt]
     */
    let retryCnt = typeof specArguments[specArguments.length - 1] === 'number' ? specArguments.pop() : 0;
    const specFn = typeof specArguments[0] === 'function' ? specArguments.shift() : typeof specArguments[1] === 'function' ? specArguments.pop() : undefined;
    const specTitle = specArguments[0];

    if (testInterfaceFnNames.indexOf(fnName) > -1) {
      if (specFn) return runSpec(specTitle, specFn, origFn, retryCnt);
      /**
       * if specFn is undefined we are dealing with a pending function
       */

      return origFn(specTitle);
    }

    return runHook(specFn, origFn, before, after, retryCnt);
  };
};
/**
 * Wraps global test function like `it` so that commands can run synchronouse
 *
 * The scope parameter is used in the qunit framework since all functions are bound to global.QUnit instead of global
 *
 * @param  {String[]} testInterfaceFnNames command that runs specs, e.g. `it`, `it.only` or `fit`
 * @param  {Function} before               before hook hook
 * @param  {Function} after                after hook hook
 * @param  {String}   fnName               test interface command to wrap, e.g. `beforeEach`
 * @param  {Object}   scope                the scope to run command from, defaults to global
 */


const runTestInFiberContext = function (testInterfaceFnNames, before, after, fnName, scope = global) {
  const origFn = scope[fnName];
  scope[fnName] = wrapTestFunction(fnName, origFn, testInterfaceFnNames, before, after);
  /**
   * support it.skip for the Mocha framework
   */

  if (typeof origFn.skip === 'function') {
    scope[fnName].skip = origFn.skip;
  }
  /**
   * wrap it.only for the Mocha framework
   */


  if (typeof origFn.only === 'function') {
    const origOnlyFn = origFn.only;
    scope[fnName].only = wrapTestFunction(fnName + '.only', origOnlyFn, testInterfaceFnNames, before, after);
  }
};

exports.runTestInFiberContext = runTestInFiberContext;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJsb2ciLCJleGVjdXRlU3luYyIsImZuIiwicmVwZWF0VGVzdCIsImFyZ3MiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlcyIsImFwcGx5IiwiZSIsInN0YWNrIiwic3BsaXQiLCJmaWx0ZXIiLCJTVEFDS1RSQUNFX0ZJTFRFUl9GTiIsImpvaW4iLCJleGVjdXRlQXN5bmMiLCJyZXN1bHQiLCJlcnJvciIsImNhdGNoIiwicnVuSG9vayIsImhvb2tGbiIsIm9yaWdGbiIsImJlZm9yZSIsImFmdGVyIiwiaG9va0Vycm9yIiwiaG9va05hbWUiLCJob29rQXJncyIsInRoZW4iLCJuYW1lIiwiY2FsbCIsInJ1blN5bmMiLCJydW5TcGVjIiwic3BlY1RpdGxlIiwic3BlY0ZuIiwiYXN5bmMiLCJzcGVjQXJncyIsInJ1biIsIndyYXBUZXN0RnVuY3Rpb24iLCJmbk5hbWUiLCJ0ZXN0SW50ZXJmYWNlRm5OYW1lcyIsInNwZWNBcmd1bWVudHMiLCJyZXRyeUNudCIsImxlbmd0aCIsInBvcCIsInNoaWZ0IiwidW5kZWZpbmVkIiwiaW5kZXhPZiIsInJ1blRlc3RJbkZpYmVyQ29udGV4dCIsInNjb3BlIiwiZ2xvYmFsIiwic2tpcCIsIm9ubHkiLCJvcmlnT25seUZuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7OztBQUVBLE1BQU1BLEdBQUcsR0FBRyxxQkFBTyxXQUFQLENBQVo7QUFFQTs7Ozs7OztBQU1BLE1BQU1DLFdBQVcsR0FBRyxVQUFVQyxFQUFWLEVBQWNDLFVBQVUsR0FBRyxDQUEzQixFQUE4QkMsSUFBSSxHQUFHLEVBQXJDLEVBQXlDO0FBQ3pEOzs7O0FBSUE7QUFFQSxTQUFPLElBQUlDLE9BQUosQ0FBWSxDQUFDQyxPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFDcEMsUUFBSTtBQUNBLFlBQU1D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SUFBZCxHQUFxQmQsZ0JBQWdCLENBQUNDLE1BQU0sR0FBRyxPQUFWLEVBQW1CYyxVQUFuQixFQUErQmIsb0JBQS9CLEVBQXFEakIsTUFBckQsRUFBNkRDLEtBQTdELENBQXJDO0FBQ0g7QUFDSixDQWxCRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBGaWJlciBmcm9tICdmaWJlcnMnXG5pbXBvcnQgbG9nZ2VyIGZyb20gJ0B3ZGlvL2xvZ2dlcidcblxuaW1wb3J0IGV4ZWN1dGVIb29rc1dpdGhBcmdzIGZyb20gJy4vZXhlY3V0ZUhvb2tzV2l0aEFyZ3MnXG5pbXBvcnQgcnVuRm5JbkZpYmVyQ29udGV4dCBmcm9tICcuL3J1bkZuSW5GaWJlckNvbnRleHQnXG5pbXBvcnQgd3JhcENvbW1hbmQgZnJvbSAnLi93cmFwQ29tbWFuZCdcblxuaW1wb3J0IHsgU1RBQ0tUUkFDRV9GSUxURVJfRk4gfSBmcm9tICcuL2NvbnN0YW50cydcbmltcG9ydCB7IGZpbHRlclNwZWNBcmdzIH0gZnJvbSAnLi91dGlscydcblxuY29uc3QgbG9nID0gbG9nZ2VyKCd3ZGlvLXN5bmMnKVxuXG4vKipcbiAqIGV4ZWN1dGUgdGVzdCBvciBob29rIHN5bmNocm9ub3VzbHlcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiAgICAgICAgIHNwZWMgb3IgaG9vayBtZXRob2RcbiAqIEBwYXJhbSAge051bWJlcn0gICByZXBlYXRUZXN0IG51bWJlciBvZiByZXRyaWVzXG4gKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICB0aGF0IGdldHMgcmVzb2x2ZWQgb25jZSB0ZXN0L2hvb2sgaXMgZG9uZSBvciB3YXMgcmV0cmllZCBlbm91Z2hcbiAqL1xuY29uc3QgZXhlY3V0ZVN5bmMgPSBmdW5jdGlvbiAoZm4sIHJlcGVhdFRlc3QgPSAwLCBhcmdzID0gW10pIHtcbiAgICAvKipcbiAgICAgKiBpZiBhIG5ldyBob29rIGdldHMgZXhlY3V0ZWQgd2UgY2FuIGFzc3VtZSB0aGF0IGFsbCBjb21tYW5kcyBzaG91bGQgaGF2ZSBmaW5pc2VkXG4gICAgICogd2l0aCBleGNlcHRpb24gb2YgdGltZW91dHMgd2hlcmUgYGNvbW1hbmRJc1J1bm5pbmdgIHdpbGwgbmV2ZXIgYmUgcmVzZXQgYnV0IGhlcmVcbiAgICAgKi9cbiAgICAvLyBjb21tYW5kSXNSdW5uaW5nID0gZmFsc2VcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBmbi5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgICAgICAgcmVzb2x2ZShyZXMpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChyZXBlYXRUZXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZXhlY3V0ZVN5bmMoZm4sIC0tcmVwZWF0VGVzdCwgYXJncykpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogbm8gbmVlZCB0byBtb2RpZnkgc3RhY2sgaWYgbm8gc3RhY2sgYXZhaWxhYmxlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghZS5zdGFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZS5zdGFjayA9IGUuc3RhY2suc3BsaXQoJ1xcbicpLmZpbHRlcihTVEFDS1RSQUNFX0ZJTFRFUl9GTikuam9pbignXFxuJylcbiAgICAgICAgICAgIHJlamVjdChlKVxuICAgICAgICB9XG4gICAgfSlcbn1cblxuLyoqXG4gKiBleGVjdXRlIHRlc3Qgb3IgaG9vayBhc3luY2hyb25vdXNseVxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgICAgICAgc3BlYyBvciBob29rIG1ldGhvZFxuICogQHBhcmFtICB7TnVtYmVyfSAgIHJlcGVhdFRlc3QgbnVtYmVyIG9mIHJldHJpZXNcbiAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgIHRoYXQgZ2V0cyByZXNvbHZlZCBvbmNlIHRlc3QvaG9vayBpcyBkb25lIG9yIHdhcyByZXRyaWVkIGVub3VnaFxuICovXG5jb25zdCBleGVjdXRlQXN5bmMgPSBmdW5jdGlvbiAoZm4sIHJlcGVhdFRlc3QgPSAwLCBhcmdzID0gW10pIHtcbiAgICBsZXQgcmVzdWx0LCBlcnJvclxuXG4gICAgLyoqXG4gICAgICogaWYgYSBuZXcgaG9vayBnZXRzIGV4ZWN1dGVkIHdlIGNhbiBhc3N1bWUgdGhhdCBhbGwgY29tbWFuZHMgc2hvdWxkIGhhdmUgZmluaXNlZFxuICAgICAqIHdpdGggZXhjZXB0aW9uIG9mIHRpbWVvdXRzIHdoZXJlIGBjb21tYW5kSXNSdW5uaW5nYCB3aWxsIG5ldmVyIGJlIHJlc2V0IGJ1dCBoZXJlXG4gICAgICovXG4gICAgLy8gY29tbWFuZElzUnVubmluZyA9IGZhbHNlXG5cbiAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBmbi5hcHBseSh0aGlzLCBhcmdzKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3IgPSBlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGFuZGxlIGVycm9ycyB0aGF0IGdldCB0aHJvd24gZGlyZWN0bHkgYW5kIGFyZSBub3QgY2F1c2UgYnlcbiAgICAgKiByZWplY3RlZCBwcm9taXNlc1xuICAgICAqL1xuICAgIGlmIChlcnJvcikge1xuICAgICAgICBpZiAocmVwZWF0VGVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVBc3luYyhmbiwgLS1yZXBlYXRUZXN0LCBhcmdzKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiByZWplY3QoZXJyb3IpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGlmIHdlIGRvbid0IHJldHJ5IGp1c3QgcmV0dXJuIHJlc3VsdFxuICAgICAqL1xuICAgIGlmIChyZXBlYXRUZXN0ID09PSAwIHx8ICFyZXN1bHQgfHwgdHlwZW9mIHJlc3VsdC5jYXRjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiByZXNvbHZlKHJlc3VsdCkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGFuZGxlIHByb21pc2UgcmVzcG9uc2VcbiAgICAgKi9cbiAgICByZXR1cm4gcmVzdWx0LmNhdGNoKChlKSA9PiB7XG4gICAgICAgIGlmIChyZXBlYXRUZXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXhlY3V0ZUFzeW5jKGZuLCAtLXJlcGVhdFRlc3QsIGFyZ3MpXG4gICAgICAgIH1cblxuICAgICAgICBlLnN0YWNrID0gZS5zdGFjay5zcGxpdCgnXFxuJykuZmlsdGVyKFNUQUNLVFJBQ0VfRklMVEVSX0ZOKS5qb2luKCdcXG4nKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSlcbiAgICB9KVxufVxuXG4vKipcbiAqIHJ1bnMgYSBob29rIHdpdGhpbiBmaWJlcnMgY29udGV4dCAoaWYgZnVuY3Rpb24gbmFtZSBpcyBub3QgYXN5bmMpXG4gKiBpdCBhbHNvIGV4ZWN1dGVzIGJlZm9yZS9hZnRlciBob29rIGhvb2tcbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gaG9va0ZuICAgICAgZnVuY3Rpb24gdGhhdCB3YXMgcGFzc2VkIHRvIHRoZSBmcmFtZXdvcmsgaG9va1xuICogQHBhcmFtICB7RnVuY3Rpb259IG9yaWdGbiAgICAgIG9yaWdpbmFsIGZyYW1ld29yayBob29rIGZ1bmN0aW9uXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gYmVmb3JlICAgICAgYmVmb3JlIGhvb2sgaG9va1xuICogQHBhcmFtICB7RnVuY3Rpb259IGFmdGVyICAgICAgIGFmdGVyIGhvb2sgaG9va1xuICogQHBhcmFtICB7TnVtYmVyfSAgIHJlcGVhdFRlc3QgIG51bWJlciBvZiByZXRyaWVzIGlmIGhvb2sgZmFpbHNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSAgICAgICAgICAgICB3cmFwcGVkIGZyYW1ld29yayBob29rIGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJ1bkhvb2sgPSBmdW5jdGlvbiAoaG9va0ZuLCBvcmlnRm4sIGJlZm9yZSwgYWZ0ZXIsIHJlcGVhdFRlc3QgPSAwKSB7XG4gICAgY29uc3QgaG9va0Vycm9yID0gKGhvb2tOYW1lKSA9PiAoZSkgPT4gbG9nLmVycm9yKGBFcnJvciBpbiAke2hvb2tOYW1lfTogJHtlLnN0YWNrfWApXG5cbiAgICByZXR1cm4gb3JpZ0ZuKGZ1bmN0aW9uICguLi5ob29rQXJncykge1xuICAgICAgICAvLyBQcmludCBlcnJvcnMgZW5jb3VudGVyZWQgaW4gYmVmb3JlSG9vayBhbmQgYWZ0ZXJIb29rIHRvIGNvbnNvbGUsIGJ1dFxuICAgICAgICAvLyBkb24ndCBwcm9wYWdhdGUgdGhlbSB0byBhdm9pZCBmYWlsaW5nIHRoZSB0ZXN0LiBIb3dldmVyLCBlcnJvcnMgaW5cbiAgICAgICAgLy8gZnJhbWV3b3JrIGhvb2sgZnVuY3Rpb25zIHNob3VsZCBmYWlsIHRoZSB0ZXN0LCBzbyBwcm9wYWdhdGUgdGhvc2UuXG4gICAgICAgIHJldHVybiBleGVjdXRlSG9va3NXaXRoQXJncyhiZWZvcmUpLmNhdGNoKGhvb2tFcnJvcignYmVmb3JlSG9vaycpKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogdXNlciB3YW50cyBoYW5kbGUgYXN5bmMgY29tbWFuZCB1c2luZyBwcm9taXNlcywgbm8gbmVlZCB0byB3cmFwIGluIGZpYmVyIGNvbnRleHRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGhvb2tGbi5uYW1lID09PSAnYXN5bmMnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVBc3luYy5jYWxsKHRoaXMsIGhvb2tGbiwgcmVwZWF0VGVzdCwgZmlsdGVyU3BlY0FyZ3MoaG9va0FyZ3MpKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocnVuU3luYy5jYWxsKHRoaXMsIGhvb2tGbiwgcmVwZWF0VGVzdCwgZmlsdGVyU3BlY0FyZ3MoaG9va0FyZ3MpKSlcbiAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZXhlY3V0ZUhvb2tzV2l0aEFyZ3MoYWZ0ZXIpLmNhdGNoKGhvb2tFcnJvcignYWZ0ZXJIb29rJykpXG4gICAgICAgIH0pXG4gICAgfSlcbn1cblxuLyoqXG4gKiBydW5zIGEgc3BlYyBmdW5jdGlvbiAodGVzdCBmdW5jdGlvbikgd2l0aGluIHRoZSBmaWJlcnMgY29udGV4dFxuICogQHBhcmFtICB7c3RyaW5nfSAgIHNwZWNUaXRsZSAgIHRlc3QgZGVzY3JpcHRpb25cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBzcGVjRm4gICAgICB0ZXN0IGZ1bmN0aW9uIHRoYXQgZ290IHBhc3NlZCBpbiBmcm9tIHRoZSB1c2VyXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gb3JpZ0ZuICAgICAgb3JpZ2luYWwgZnJhbWV3b3JrIHRlc3QgZnVuY3Rpb25cbiAqIEBwYXJhbSAge051bWJlcn0gICByZXBlYXRUZXN0ICBudW1iZXIgb2YgcmV0cmllcyBpZiB0ZXN0IGZhaWxzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gICAgICAgICAgICAgd3JhcHBlZCB0ZXN0IGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJ1blNwZWMgPSBmdW5jdGlvbiAoc3BlY1RpdGxlLCBzcGVjRm4sIG9yaWdGbiwgcmVwZWF0VGVzdCA9IDApIHtcbiAgICAvKipcbiAgICAgKiB1c2VyIHdhbnRzIGhhbmRsZSBhc3luYyBjb21tYW5kIHVzaW5nIHByb21pc2VzLCBubyBuZWVkIHRvIHdyYXAgaW4gZmliZXIgY29udGV4dFxuICAgICAqL1xuICAgIGlmIChzcGVjRm4ubmFtZSA9PT0gJ2FzeW5jJykge1xuICAgICAgICByZXR1cm4gb3JpZ0ZuKHNwZWNUaXRsZSwgZnVuY3Rpb24gYXN5bmMgKC4uLnNwZWNBcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhlY3V0ZUFzeW5jLmNhbGwodGhpcywgc3BlY0ZuLCByZXBlYXRUZXN0LCBmaWx0ZXJTcGVjQXJncyhzcGVjQXJncykpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIG9yaWdGbihzcGVjVGl0bGUsIGZ1bmN0aW9uICguLi5zcGVjQXJncykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocnVuU3luYy5jYWxsKHRoaXMsIHNwZWNGbiwgcmVwZWF0VGVzdCwgZmlsdGVyU3BlY0FyZ3Moc3BlY0FyZ3MpKSlcbiAgICB9KVxufVxuXG4vKipcbiAqIHJ1biBob29rIG9yIHNwZWMgdmlhIGV4ZWN1dGVTeW5jXG4gKi9cbmZ1bmN0aW9uIHJ1blN5bmMgKGZuLCByZXBlYXRUZXN0ID0gMCwgYXJncyA9IFtdKSB7XG4gICAgcmV0dXJuIChyZXNvbHZlLCByZWplY3QpID0+XG4gICAgICAgIEZpYmVyKCgpID0+IGV4ZWN1dGVTeW5jLmNhbGwodGhpcywgZm4sIHJlcGVhdFRlc3QsIGFyZ3MpLnRoZW4oKCkgPT4gcmVzb2x2ZSgpLCByZWplY3QpKS5ydW4oKVxufVxuXG4vKipcbiAqIHdyYXBzIGhvb2tzIGFuZCB0ZXN0IGZ1bmN0aW9uIG9mIGEgZnJhbWV3b3JrIHdpdGhpbiBhIGZpYmVyIGNvbnRleHRcbiAqIEBwYXJhbSAge1N0cmluZ30gICBmbk5hbWUgICAgICAgICAgICAgICBzcGVjIGZ1bmN0aW9uIHRoYXQgaXMgYmVpbmcgb3ZlcndyaXR0ZW5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBvcmlnRm4gICAgICAgICAgICAgICBvcmlnaW5hbCBmcmFtZXdvcmsgZnVuY3Rpb25cbiAqIEBwYXJhbSAge1N0cmluZ1tdfSB0ZXN0SW50ZXJmYWNlRm5OYW1lcyBjb21tYW5kIHRoYXQgcnVucyBzcGVjcywgZS5nLiBgaXRgLCBgaXQub25seWAgb3IgYGZpdGBcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBiZWZvcmUgICAgICAgICAgICAgICBiZWZvcmUgaG9vayBob29rXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gYWZ0ZXIgICAgICAgICAgICAgICAgYWZ0ZXIgaG9vayBob29rXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gICAgICAgICAgICAgICAgICAgICAgd3JhcHBlZCB0ZXN0L2hvb2sgZnVuY3Rpb25cbiAqL1xuY29uc3Qgd3JhcFRlc3RGdW5jdGlvbiA9IGZ1bmN0aW9uIChmbk5hbWUsIG9yaWdGbiwgdGVzdEludGVyZmFjZUZuTmFtZXMsIGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLnNwZWNBcmd1bWVudHMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhcmlhZGljIGFyZ3VtZW50czpcbiAgICAgICAgICogW3RpdGxlLCBmbl0sIFt0aXRsZV0sIFtmbl1cbiAgICAgICAgICogW3RpdGxlLCBmbiwgcmV0cnlDbnRdLCBbdGl0bGUsIHJldHJ5Q250XSwgW2ZuLCByZXRyeUNudF1cbiAgICAgICAgICovXG4gICAgICAgIGxldCByZXRyeUNudCA9IHR5cGVvZiBzcGVjQXJndW1lbnRzW3NwZWNBcmd1bWVudHMubGVuZ3RoIC0gMV0gPT09ICdudW1iZXInID8gc3BlY0FyZ3VtZW50cy5wb3AoKSA6IDBcbiAgICAgICAgY29uc3Qgc3BlY0ZuID0gdHlwZW9mIHNwZWNBcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgPyBzcGVjQXJndW1lbnRzLnNoaWZ0KClcbiAgICAgICAgICAgIDogKHR5cGVvZiBzcGVjQXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nID8gc3BlY0FyZ3VtZW50cy5wb3AoKSA6IHVuZGVmaW5lZClcbiAgICAgICAgY29uc3Qgc3BlY1RpdGxlID0gc3BlY0FyZ3VtZW50c1swXVxuXG4gICAgICAgIGlmICh0ZXN0SW50ZXJmYWNlRm5OYW1lcy5pbmRleE9mKGZuTmFtZSkgPiAtMSkge1xuICAgICAgICAgICAgaWYgKHNwZWNGbikgcmV0dXJuIHJ1blNwZWMoc3BlY1RpdGxlLCBzcGVjRm4sIG9yaWdGbiwgcmV0cnlDbnQpXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogaWYgc3BlY0ZuIGlzIHVuZGVmaW5lZCB3ZSBhcmUgZGVhbGluZyB3aXRoIGEgcGVuZGluZyBmdW5jdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gb3JpZ0ZuKHNwZWNUaXRsZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBydW5Ib29rKHNwZWNGbiwgb3JpZ0ZuLCBiZWZvcmUsIGFmdGVyLCByZXRyeUNudClcbiAgICB9XG59XG5cbi8qKlxuICogV3JhcHMgZ2xvYmFsIHRlc3QgZnVuY3Rpb24gbGlrZSBgaXRgIHNvIHRoYXQgY29tbWFuZHMgY2FuIHJ1biBzeW5jaHJvbm91c2VcbiAqXG4gKiBUaGUgc2NvcGUgcGFyYW1ldGVyIGlzIHVzZWQgaW4gdGhlIHF1bml0IGZyYW1ld29yayBzaW5jZSBhbGwgZnVuY3Rpb25zIGFyZSBib3VuZCB0byBnbG9iYWwuUVVuaXQgaW5zdGVhZCBvZiBnbG9iYWxcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmdbXX0gdGVzdEludGVyZmFjZUZuTmFtZXMgY29tbWFuZCB0aGF0IHJ1bnMgc3BlY3MsIGUuZy4gYGl0YCwgYGl0Lm9ubHlgIG9yIGBmaXRgXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gYmVmb3JlICAgICAgICAgICAgICAgYmVmb3JlIGhvb2sgaG9va1xuICogQHBhcmFtICB7RnVuY3Rpb259IGFmdGVyICAgICAgICAgICAgICAgIGFmdGVyIGhvb2sgaG9va1xuICogQHBhcmFtICB7U3RyaW5nfSAgIGZuTmFtZSAgICAgICAgICAgICAgIHRlc3QgaW50ZXJmYWNlIGNvbW1hbmQgdG8gd3JhcCwgZS5nLiBgYmVmb3JlRWFjaGBcbiAqIEBwYXJhbSAge09iamVjdH0gICBzY29wZSAgICAgICAgICAgICAgICB0aGUgc2NvcGUgdG8gcnVuIGNvbW1hbmQgZnJvbSwgZGVmYXVsdHMgdG8gZ2xvYmFsXG4gKi9cbmNvbnN0IHJ1blRlc3RJbkZpYmVyQ29udGV4dCA9IGZ1bmN0aW9uICh0ZXN0SW50ZXJmYWNlRm5OYW1lcywgYmVmb3JlLCBhZnRlciwgZm5OYW1lLCBzY29wZSA9IGdsb2JhbCkge1xuICAgIGNvbnN0IG9yaWdGbiA9IHNjb3BlW2ZuTmFtZV1cbiAgICBzY29wZVtmbk5hbWVdID0gd3JhcFRlc3RGdW5jdGlvbihmbk5hbWUsIG9yaWdGbiwgdGVzdEludGVyZmFjZUZuTmFtZXMsIGJlZm9yZSwgYWZ0ZXIpXG5cbiAgICAvKipcbiAgICAgKiBzdXBwb3J0IGl0LnNraXAgZm9yIHRoZSBNb2NoYSBmcmFtZXdvcmtcbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIG9yaWdGbi5za2lwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHNjb3BlW2ZuTmFtZV0uc2tpcCA9IG9yaWdGbi5za2lwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogd3JhcCBpdC5vbmx5IGZvciB0aGUgTW9jaGEgZnJhbWV3b3JrXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiBvcmlnRm4ub25seSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCBvcmlnT25seUZuID0gb3JpZ0ZuLm9ubHlcbiAgICAgICAgc2NvcGVbZm5OYW1lXS5vbmx5ID0gd3JhcFRlc3RGdW5jdGlvbihmbk5hbWUgKyAnLm9ubHknLCBvcmlnT25seUZuLCB0ZXN0SW50ZXJmYWNlRm5OYW1lcywgYmVmb3JlLCBhZnRlcilcbiAgICB9XG59XG5cbmV4cG9ydCB7XG4gICAgZXhlY3V0ZUhvb2tzV2l0aEFyZ3MsXG4gICAgd3JhcENvbW1hbmQsXG4gICAgcnVuVGVzdEluRmliZXJDb250ZXh0LFxuICAgIHJ1bkZuSW5GaWJlckNvbnRleHQsXG4gICAgZXhlY3V0ZVN5bmMsXG4gICAgZXhlY3V0ZUFzeW5jXG59XG4iXX0=